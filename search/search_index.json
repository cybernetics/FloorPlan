{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Render Room schemas into ER diagrams. Once you have a JSON representation of your Room exported schema , you can use FloorPlan to transform it into a DBML or DOT representation, or into SVG and PNG files, to then be checked back into the repository. Diagram rendering FloorPlan supports rendering to multiple formats, including SVG vectors , PNG and DOT , via its integration with the GraphViz visualization library . See an example of Tivi's 's schema (v26) when rendered into a SVG file: Database Markup Language (DBML) . DBML (Database Markup Language) is an open-source DSL language designed to define and document database schemas and structures. It is designed to be simple, consistent and highly-readable. FloorPlan provides a translation mechanism from the input database schemas into DBML, that can be later used for other interesting applications, like ER diagram rendering or in as an input for Pull Request revision on a development process. DBML parser With a few manual tweaks, DBML can also be used directly as an input to the rendering mechanism, by skipping the pipeline's JSON-consumption step. dbdiagram dbdiagram is a free, simple tool to draw ER diagrams, that can be used to render the DBML output of FloorPlan. For instance, when translating Tivi 's schema (v26) , this is the rendered output in dbdiagram: Note FloorPlan and its developers are in no way associated to dbdiagram.","title":"Overview"},{"location":"#diagram-rendering","text":"FloorPlan supports rendering to multiple formats, including SVG vectors , PNG and DOT , via its integration with the GraphViz visualization library . See an example of Tivi's 's schema (v26) when rendered into a SVG file:","title":"Diagram rendering"},{"location":"#database-markup-language-dbml","text":"DBML (Database Markup Language) is an open-source DSL language designed to define and document database schemas and structures. It is designed to be simple, consistent and highly-readable. FloorPlan provides a translation mechanism from the input database schemas into DBML, that can be later used for other interesting applications, like ER diagram rendering or in as an input for Pull Request revision on a development process.","title":"Database Markup Language (DBML)."},{"location":"#dbml-parser","text":"With a few manual tweaks, DBML can also be used directly as an input to the rendering mechanism, by skipping the pipeline's JSON-consumption step.","title":"DBML parser"},{"location":"#dbdiagram","text":"dbdiagram is a free, simple tool to draw ER diagrams, that can be used to render the DBML output of FloorPlan. For instance, when translating Tivi 's schema (v26) , this is the rendered output in dbdiagram: Note FloorPlan and its developers are in no way associated to dbdiagram.","title":"dbdiagram"},{"location":"architecture/","text":"Modularization FloorPlan's source code is distributed across multiple modules, each responsible for one aspect of domain modeling or one stage of the processing pipeline. floorplan-cli Home for the command line argument parsing logic, and general aspects of application bootstrapping. The cli module is one possible interaction point between users and FloorPlan, but can be replaced by other user interfaces, like a Gradle plug-in or potentially a fully-fledged GUI application. DBML models Barebones Kotlin models of the DBML object concepts. This module has no logic in it other than housing the domain representations of Tables, References, Indexes, etc. Processing pipeline Consumer This stage of the processing pipeline is responsible for translating the user input files into DBML models, representing each of the entities and relationships. So far, FloorPlan processes: Room schemas, by deserializing their JSON representations (see sample ) on the :room-consumer module. SQLite db files, by connecting to them via a JDBC driver and query metadata of entities and relationships. DBML schema files. Visualization Depending on the output file format, FloorPlan uses different mechanisms to translate the input. The DBML models are rendered as text by a module of its own , while FloorPlan relies on GraphViz visualization library to render image representations.","title":"Architecture"},{"location":"architecture/#modularization","text":"FloorPlan's source code is distributed across multiple modules, each responsible for one aspect of domain modeling or one stage of the processing pipeline.","title":"Modularization"},{"location":"architecture/#floorplan-cli","text":"Home for the command line argument parsing logic, and general aspects of application bootstrapping. The cli module is one possible interaction point between users and FloorPlan, but can be replaced by other user interfaces, like a Gradle plug-in or potentially a fully-fledged GUI application.","title":"floorplan-cli"},{"location":"architecture/#dbml-models","text":"Barebones Kotlin models of the DBML object concepts. This module has no logic in it other than housing the domain representations of Tables, References, Indexes, etc.","title":"DBML models"},{"location":"architecture/#processing-pipeline","text":"","title":"Processing pipeline"},{"location":"architecture/#consumer","text":"This stage of the processing pipeline is responsible for translating the user input files into DBML models, representing each of the entities and relationships. So far, FloorPlan processes: Room schemas, by deserializing their JSON representations (see sample ) on the :room-consumer module. SQLite db files, by connecting to them via a JDBC driver and query metadata of entities and relationships. DBML schema files.","title":"Consumer"},{"location":"architecture/#visualization","text":"Depending on the output file format, FloorPlan uses different mechanisms to translate the input. The DBML models are rendered as text by a module of its own , while FloorPlan relies on GraphViz visualization library to render image representations.","title":"Visualization"},{"location":"changelog/","text":"Changelog 0.2 Add SQLite-based consumer, with driver to connect to .db files. We now allow for rendering schemas for popular SQLite ORMs, such as SQLDelight and Core Data. Add DBML consumer, to allow for rendering schemas directly from .dbml files. :dbml-parser now parses Index es. 0.1 Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#02","text":"Add SQLite-based consumer, with driver to connect to .db files. We now allow for rendering schemas for popular SQLite ORMs, such as SQLDelight and Core Data. Add DBML consumer, to allow for rendering schemas directly from .dbml files. :dbml-parser now parses Index es.","title":"0.2"},{"location":"changelog/#01","text":"Initial release.","title":"0.1"},{"location":"contributing/","text":"Contributing Thank you for your interest in contributing to FloorPlan! Setup Check out the project Download IntelliJ IDEA or Android Studio and import it. Build Build the CLI and its subprojects with ./gradlew :floorplan-cli:build . Build the Gradle Plugin: Publish a snapshot to your local maven repository: ./gradlew :floorplan-gradle-plugin:publishToMavenLocal Enable the sample app building: echo floorplan.includeSampleApp=true >> ~/.gradle/gradle.properties (Optionally) Trigger the task on the sample app with ./gradlew :sample-android-project:generateFloorPlan Note: Gradle Plugin - workflow The gradle plugin development workflow requires republishing of the latest builds to mavenLocal after each code change. You will need to the deployment steps above if you want to manually test the changes in an end-to-end fashion with the help of the sample Android application. Tests The project is unit tested and has integration tests for its Gradle plugin. These can be run via Gradle with: gradlew test You can also run only the Gradle Plugin tests by specifying that task explicitly: gradlew :floorplan-gradle-plugin:test Deploying the docs locally Install mkdocs and the required extensions: pip install -r requirements.txt Deploy it locally: mkdocs serve Release Create a local release branch from master git checkout master git pull git checkout -b release_<next-release-version> Update floorPlanVersion in the versioning.gradle (remove -SNAPSHOT ) floorPlanVersion = \"<next-release-version>\" Update docs/changelog.md after checking out all changes: https://github.com/julioz/FloorPlan/compare/v <current-release-version> ...master Take one last look git diff Commit all local changes git commit -am \"Prepare <next-release-version> release.\" Perform a clean build ./gradlew clean ./gradlew build Create a tag and push it git tag v<next-release-version> git push origin v<next-release-version> Make sure you have valid credentials in ~/.gradle/gradle.properties to upload the artifacts SONATYPE_NEXUS_USERNAME= SONATYPE_NEXUS_PASSWORD= Upload the artifacts to Sonatype OSS Nexus ./gradlew publish --no-daemon --no-parallel Release to Maven Central Login to Sonatype OSS Nexus Click on Staging Repositories Scroll to the bottom, you should see an entry named comjuliozynger-XXXX Check the box next to the comjuliozynger-XXXX entry, click Close then Confirm Wait a bit, hit Refresh , until the Status for that column changes to Closed . Check the box next to the comjuliozynger-XXXX entry, click Release then Confirm Release to Gradle Plugin Portal ./gradlew publishPlugins Merge the release branch to master git checkout master git pull git merge --no-ff release_<next-release-version> Update floorPlanVersion in versioning.gradle (increase version and add -SNAPSHOT ) floorPlanVersion = \"REPLACE_WITH_NEXT_VERSION_NUMBER-SNAPSHOT\" Commit your changes git commit -am \"Prepare for next development iteration.\" Push your changes git push","title":"Contributing"},{"location":"contributing/#contributing","text":"Thank you for your interest in contributing to FloorPlan!","title":"Contributing"},{"location":"contributing/#setup","text":"Check out the project Download IntelliJ IDEA or Android Studio and import it.","title":"Setup"},{"location":"contributing/#build","text":"Build the CLI and its subprojects with ./gradlew :floorplan-cli:build . Build the Gradle Plugin: Publish a snapshot to your local maven repository: ./gradlew :floorplan-gradle-plugin:publishToMavenLocal Enable the sample app building: echo floorplan.includeSampleApp=true >> ~/.gradle/gradle.properties (Optionally) Trigger the task on the sample app with ./gradlew :sample-android-project:generateFloorPlan Note: Gradle Plugin - workflow The gradle plugin development workflow requires republishing of the latest builds to mavenLocal after each code change. You will need to the deployment steps above if you want to manually test the changes in an end-to-end fashion with the help of the sample Android application.","title":"Build"},{"location":"contributing/#tests","text":"The project is unit tested and has integration tests for its Gradle plugin. These can be run via Gradle with: gradlew test You can also run only the Gradle Plugin tests by specifying that task explicitly: gradlew :floorplan-gradle-plugin:test","title":"Tests"},{"location":"contributing/#deploying-the-docs-locally","text":"Install mkdocs and the required extensions: pip install -r requirements.txt Deploy it locally: mkdocs serve","title":"Deploying the docs locally"},{"location":"contributing/#release","text":"Create a local release branch from master git checkout master git pull git checkout -b release_<next-release-version> Update floorPlanVersion in the versioning.gradle (remove -SNAPSHOT ) floorPlanVersion = \"<next-release-version>\" Update docs/changelog.md after checking out all changes: https://github.com/julioz/FloorPlan/compare/v <current-release-version> ...master Take one last look git diff Commit all local changes git commit -am \"Prepare <next-release-version> release.\" Perform a clean build ./gradlew clean ./gradlew build Create a tag and push it git tag v<next-release-version> git push origin v<next-release-version> Make sure you have valid credentials in ~/.gradle/gradle.properties to upload the artifacts SONATYPE_NEXUS_USERNAME= SONATYPE_NEXUS_PASSWORD= Upload the artifacts to Sonatype OSS Nexus ./gradlew publish --no-daemon --no-parallel Release to Maven Central Login to Sonatype OSS Nexus Click on Staging Repositories Scroll to the bottom, you should see an entry named comjuliozynger-XXXX Check the box next to the comjuliozynger-XXXX entry, click Close then Confirm Wait a bit, hit Refresh , until the Status for that column changes to Closed . Check the box next to the comjuliozynger-XXXX entry, click Release then Confirm Release to Gradle Plugin Portal ./gradlew publishPlugins Merge the release branch to master git checkout master git pull git merge --no-ff release_<next-release-version> Update floorPlanVersion in versioning.gradle (increase version and add -SNAPSHOT ) floorPlanVersion = \"REPLACE_WITH_NEXT_VERSION_NUMBER-SNAPSHOT\" Commit your changes git commit -am \"Prepare for next development iteration.\" Push your changes git push","title":"Release"},{"location":"gradle-plugin/","text":"FloorPlan as a Gradle Plugin Apply the plugin Apply the gradle plugin in your root build.gradle file: buildscript { dependencies { classpath \"com.juliozynger.floorplan:floorplan-gradle-plugin:<version>\" } } and in the modules you want FloorPlan 's Gradle task to exist. For example, in an Android application module: plugins { id 'com.android.application' // could be library or any other module id 'com.juliozynger.floorplan' } Gradle extension Configure FloorPlan's Gradle extension by definining a floorPlan block: floorPlan { schemaLocation = \"$projectDir/schemas\".toString() outputLocation = \"$projectDir/floorplan-output\".toString() outputFormat { svg { enabled = true } } } Output formats FloorPlan is able to output different file formats. Take a look at what a full configuration would look like, defining DBML and SVG as output formats (and providing extra configurations for DBML ): floorPlan { schemaLocation = \"$projectDir/schemas\".toString() outputLocation = \"$projectDir/floorplan-output\".toString() outputFormat { dbml { enabled = true creationSqlAsTableNote = false renderNullableFields = false } svg { enabled = true } png { enabled = false } dot { enabled = false } } } Generate Floor Plan Once everything is setup, you can finally run FloorPlan to translate database schemas into ER diagrams. For example, to generate the diagrams associated to the sample-android-project module schemas, we can run: ./gradlew :sample-android-project:generateFloorPlan","title":"Gradle Plugin"},{"location":"gradle-plugin/#floorplan-as-a-gradle-plugin","text":"","title":"FloorPlan as a Gradle Plugin"},{"location":"gradle-plugin/#apply-the-plugin","text":"Apply the gradle plugin in your root build.gradle file: buildscript { dependencies { classpath \"com.juliozynger.floorplan:floorplan-gradle-plugin:<version>\" } } and in the modules you want FloorPlan 's Gradle task to exist. For example, in an Android application module: plugins { id 'com.android.application' // could be library or any other module id 'com.juliozynger.floorplan' }","title":"Apply the plugin"},{"location":"gradle-plugin/#gradle-extension","text":"Configure FloorPlan's Gradle extension by definining a floorPlan block: floorPlan { schemaLocation = \"$projectDir/schemas\".toString() outputLocation = \"$projectDir/floorplan-output\".toString() outputFormat { svg { enabled = true } } }","title":"Gradle extension"},{"location":"gradle-plugin/#output-formats","text":"FloorPlan is able to output different file formats. Take a look at what a full configuration would look like, defining DBML and SVG as output formats (and providing extra configurations for DBML ): floorPlan { schemaLocation = \"$projectDir/schemas\".toString() outputLocation = \"$projectDir/floorplan-output\".toString() outputFormat { dbml { enabled = true creationSqlAsTableNote = false renderNullableFields = false } svg { enabled = true } png { enabled = false } dot { enabled = false } } }","title":"Output formats"},{"location":"gradle-plugin/#generate-floor-plan","text":"Once everything is setup, you can finally run FloorPlan to translate database schemas into ER diagrams. For example, to generate the diagrams associated to the sample-android-project module schemas, we can run: ./gradlew :sample-android-project:generateFloorPlan","title":"Generate Floor Plan"},{"location":"intellij-plugin/","text":"FloorPlan as an IntelliJ Plugin FloorPlan has a (incubating) plug-in for IDEs based on the IntelliJ platform (IDEA, Android Studio, AppCode, CLion, etc.) The plug-in will scan the file system for FloorPlan's output files and display them as a gutter action in the IDEA sidebar for extra discoverability and easy access. Download and install Given the incubating nature of the plugin, it is not distributed through JetBrains plug-in repository . Download the plug-in zip file and follow the 'instalation from disk' steps . Building The source code is available in the :floorplan-intellij-plugin module . It relies on Gradle and the intellij DevKit to manipulate the PSI tree. Deploy an artifact for local debugging with ./gradlew runIde . For manual distribution or local installation, invoke gradlew buildPlugin target to create the plugin distribution. The resulting JAR / ZIP is located in build/distributions and can then be installed .","title":"IntelliJ Plugin"},{"location":"intellij-plugin/#floorplan-as-an-intellij-plugin","text":"FloorPlan has a (incubating) plug-in for IDEs based on the IntelliJ platform (IDEA, Android Studio, AppCode, CLion, etc.) The plug-in will scan the file system for FloorPlan's output files and display them as a gutter action in the IDEA sidebar for extra discoverability and easy access.","title":"FloorPlan as an IntelliJ Plugin"},{"location":"intellij-plugin/#download-and-install","text":"Given the incubating nature of the plugin, it is not distributed through JetBrains plug-in repository . Download the plug-in zip file and follow the 'instalation from disk' steps .","title":"Download and install"},{"location":"intellij-plugin/#building","text":"The source code is available in the :floorplan-intellij-plugin module . It relies on Gradle and the intellij DevKit to manipulate the PSI tree. Deploy an artifact for local debugging with ./gradlew runIde . For manual distribution or local installation, invoke gradlew buildPlugin target to create the plugin distribution. The resulting JAR / ZIP is located in build/distributions and can then be installed .","title":"Building"},{"location":"run/","text":"Run FloorPlan from the command line After checking out this repository, make sure you have Gradle installed and run: gradlew run --args=\"<path-to-schema-file>\" Command-line arguments Output format FloorPlan can render many different output formats, specified by the --format argument: gradlew run --args=\"<path-to-schema-file> --format=<output-format>\" Currently, the supported formats are: DBML SVG PNG DOT Info Multiple output formats can be specified through a comma-separated list: gradlew run --args=\"<path-to-schema-file> --format=<format1>,<format2>,<format3>\" Info When not present, DBML is picked as default value as output format. Warning Some arguments are restricted to their combination with the specified output format. Refer to the individual argument documentation to verify its availability. Write output to file gradlew run --args=\"<path-to-schema-file> --output=<path-to-output-file>\" Add CREATION SQL as Table note This option is disabled by default since it can be quite verbose and would 'duplicate' what a UI rendering tool (better) provides. Opt-in by specifying: gradlew run --args=\"<path-to-schema-file> --creation-sql-as-table-note\" Availability: DBML Only available when the output format is DBML. Render nullable fields in data types This option is disabled by default , opt-in with: gradlew run --args=\"<path-to-schema-file> --render-nullable-fields\" Availability: DBML Only available when the output format is DBML.","title":"Command-line"},{"location":"run/#run-floorplan-from-the-command-line","text":"After checking out this repository, make sure you have Gradle installed and run: gradlew run --args=\"<path-to-schema-file>\"","title":"Run FloorPlan from the command line"},{"location":"run/#command-line-arguments","text":"","title":"Command-line arguments"},{"location":"run/#output-format","text":"FloorPlan can render many different output formats, specified by the --format argument: gradlew run --args=\"<path-to-schema-file> --format=<output-format>\" Currently, the supported formats are: DBML SVG PNG DOT Info Multiple output formats can be specified through a comma-separated list: gradlew run --args=\"<path-to-schema-file> --format=<format1>,<format2>,<format3>\" Info When not present, DBML is picked as default value as output format. Warning Some arguments are restricted to their combination with the specified output format. Refer to the individual argument documentation to verify its availability.","title":"Output format"},{"location":"run/#write-output-to-file","text":"gradlew run --args=\"<path-to-schema-file> --output=<path-to-output-file>\"","title":"Write output to file"},{"location":"run/#add-creation-sql-as-table-note","text":"This option is disabled by default since it can be quite verbose and would 'duplicate' what a UI rendering tool (better) provides. Opt-in by specifying: gradlew run --args=\"<path-to-schema-file> --creation-sql-as-table-note\" Availability: DBML Only available when the output format is DBML.","title":"Add CREATION SQL as Table note"},{"location":"run/#render-nullable-fields-in-data-types","text":"This option is disabled by default , opt-in with: gradlew run --args=\"<path-to-schema-file> --render-nullable-fields\" Availability: DBML Only available when the output format is DBML.","title":"Render nullable fields in data types"},{"location":"recipes/android-room/","text":"FloorPlan & Room The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite. Room can export your database's schema information into a JSON file at compile time. To export the schema, set the room.schemaLocation annotation processor property (or kapt , if you use Kotlin) in your build.gradle file. The JSON schemas can, then, be passed to FloorPlan as an input parameter for its rendering generation. Here we see an example with FloorPlan's Gradle Plugin : android { ... defaultConfig { ... javaCompileOptions { annotationProcessorOptions { arguments += [\"room.schemaLocation\": \"$projectDir/schemas\".toString()] } } } } ... floorPlan { schemaLocation = \"$projectDir/schemas\".toString() ... }","title":"Android Room"},{"location":"recipes/android-room/#floorplan-room","text":"The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite. Room can export your database's schema information into a JSON file at compile time. To export the schema, set the room.schemaLocation annotation processor property (or kapt , if you use Kotlin) in your build.gradle file. The JSON schemas can, then, be passed to FloorPlan as an input parameter for its rendering generation. Here we see an example with FloorPlan's Gradle Plugin : android { ... defaultConfig { ... javaCompileOptions { annotationProcessorOptions { arguments += [\"room.schemaLocation\": \"$projectDir/schemas\".toString()] } } } } ... floorPlan { schemaLocation = \"$projectDir/schemas\".toString() ... }","title":"FloorPlan &amp; Room"},{"location":"recipes/sqldelight/","text":"FloorPlan & SQLDelight In order to use SQLDelight schemas as input to FloorPlan, make sure you are on a recent version of library (>=1.0). When applying SQLDelight's Gradle plugin, specify the following gradle extension to configure it to output .db files. sqldelight { <databaseName> { packageName = \"<fully qualified package name to where the database is generated>\" schemaOutputDirectory = file(\"<output directory for the db file>\") } } Once done, running ./gradlew <module>:tasks will uncover a generateSchema gradle task per build type (usually debug , release , etc.). ./gradlew generate<buildType><projectName>Schema will output a .db file can be used as an input to FloorPlan , via its CLI or Gradle Plugin interfaces. Note Read more about SQLDelight's configuration on the project's website .","title":"SQLDelight"},{"location":"recipes/sqldelight/#floorplan-sqldelight","text":"In order to use SQLDelight schemas as input to FloorPlan, make sure you are on a recent version of library (>=1.0). When applying SQLDelight's Gradle plugin, specify the following gradle extension to configure it to output .db files. sqldelight { <databaseName> { packageName = \"<fully qualified package name to where the database is generated>\" schemaOutputDirectory = file(\"<output directory for the db file>\") } } Once done, running ./gradlew <module>:tasks will uncover a generateSchema gradle task per build type (usually debug , release , etc.). ./gradlew generate<buildType><projectName>Schema will output a .db file can be used as an input to FloorPlan , via its CLI or Gradle Plugin interfaces. Note Read more about SQLDelight's configuration on the project's website .","title":"FloorPlan &amp; SQLDelight"}]}